# 실습03 - 인터럽트, 트랩, 시스템 콜

## 커널 모드 진입

- 유저 모드에서 커널 모드로 직접 접근하는 것은 안된다 → 막아놨음
- 따라서 interrupt, trap, system call 로 간접적으로 커널 모드에 진입할 수 있다

## 인터럽트, 시스템콜, 트랩 이걸로 끝낸다

- 일단 인터럽트는 외부 인터럽트와 내부 인터럽트로 나뉘고 내부 인터럽트를 트랩이라고 부르며 시스템 콜은 트랩의 일종이다

### 외부 인터럽트, 트랩, 시스템 콜

- **외부 인터럽트** : 하드웨어적인(현재 실행중인 프로세스와 무관하게, 비동기적으로 - 여기서 비동기라는 것은 언제 발생할지 모른다는 것을 의미함) 이벤트에 의한 것
- **내부 인터럽트(트랩)** : 현재 실행중인 프로세스에서(동기적으로) 이벤트가 발생한 것
- **시스템 콜** : 현재 유저모드인 프로세스가 커널의 서비스를 이용하기 위해 의도적으로 트랩을 거는 것

### 인터럽트와 시스템 콜의 처리 과정

- 일단 리눅스 시스템에서는 시스템 콜도 트랩을 이용하여 처리한다
- 핸들러의 주소가 모여있는 IDT(IVT)가 존재하는데 이중에 0-31번까지는 트랩 핸들러들의 주소가 저장되어있고(이부분을 **trap handler table**라고 한다), 나머지는 외부 인터럽트 핸들러(이부분은 **IRQ**라고 한다)이다. 그리고 0x80에 syscall함수의 주소가 들어있어 시스템 콜은 이 함수를 이용해 처리하게 된다
- 트랩과 외부 인터럽트의 경우에는 바로 핸들러로 접근할 수 있게 IDT에 핸들러의 주소가 바로 명시돼있는 한편, 시스템 콜의 경우에는 IDT에서 특정 핸들러로 바로 접근할 수 있는게 아닌 sys call table에 접근하는 함수(syscall함수)에 먼저 접근하게되어 있다.여기로 접근해 함수를 실행해 시스템 콜 핸들러들의 주소로 접근하게 되는 것(이중으로 접근해야 되는 셈)
- 즉, 외부 인터럽트와 트랩의 처리과정은 다음과 같다 :
    - 유저모드에서 인터럽트가 발생 → 커널모드로 전환 → context saving → IDT에 접근하여 해당 interrupt handler의 주소에 접근 → 실행 / 처리 → context restore
- 반면에 시스템 콜의 처리과정은 다음과 같다 :
    1. 유저모드에서 시스템 콜 호출
    2. libc.a라는 라이브러리에서 해당 시스템 콜 에 관한 함수를 실행
    3. 이 함수에서는 호출한 syscall의 번호를 레지스터에 저장하고(fork()를 예로 들면 이 함수의 고유번호는 2 이므로 이것을 레지스터에 저장한다) int 0x80이라는 instruction을 실행해 0x80 인터럽트를 걸게 된다(syscall이 IDT에 저장된 주소가 0x80이므로)
    4. Context saving 후 커널모드로 전환
    5. IDT에 접근하여 0x80에 접근해 syscall()함수를 실행한다
    6. 이 함수에서는 레지스터에 저장된 syscall번호(fork의 경우 2)와 syscall table를 이용해 그 번호에 해당하는 syscall handler를 실행하게 된다
    7. 실행 / 처리
    8. 처리후에는 다시 syscall()함수로 복귀해 ret_from_syscall()이라는 함수를 실행시켜 context restore하고 원래의 프로세스로 복귀한다.

## Context saving, restore, switching

- **context saving**은 현 작업을 저장하는거고 **context restore**은 저장돼있던 작업을 다시 불러오는 것, **context switching**은 현 작업을 다른 작업으로 전환하는 것
- switching전에는 반드시 saving이 일어나지만 saving후 반드시 switch되는건 아님 → 다시 saving한 곳으로 restore될 수도 있댄다