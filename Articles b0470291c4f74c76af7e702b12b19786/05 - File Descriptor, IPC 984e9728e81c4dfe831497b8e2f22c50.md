# 05 - File Descriptor, IPC

## File Descriptor

- 유닉스 시스텝에서는 모든걸 “파일”로 관리한다
- 파일이라 그러니까 txt같은 파일이랑 헷갈리는데 그냥 뭐 프로세스, (진짜)파일, 디렉토리, 파이프 등등을 **”파일”**이라고 통칭한다고 생각하면 된다
- 이렇게 모든 걸 “파일”로 관리할 때 그 “파일”들에 인덱스를 매긴 것을 **File descriptor**라고 한다
- 즉, 다시 말하면 시스템이 만들어 놓은 것들을 우리가 사용하려고 할 때 편하게 사용하기 위해 정수로 숫자를 매겨놓은 것을 File descriptor라고 생각하면 된다
- 봐봐라
    - fopen()이라는 함수를 사용해서 파일을 열면 반환값으로 FILE 자료형의 값이 나와 이것을 어따가 저장해뒀다가 파일을 쓰고자 할 때 사용하자네
    - 근데 이거 말고 그냥 open()함수를 실행시키면 int 값을 반환하는데 또 이걸 이용해서도 파일에 접근한단말이제
    - 이렇게 파일을 이용할때 간단히 int값의 인덱스를 이용해 파일에 접근하게 해주는 이게 파일 디스크립터다 이말이야
- 특정 프로세스가 열어놓은 “파일”들이 무엇인지 알아보기 위해 lsof라는 명령어를사용할 수 있다

lsof -p PID_

- 이렇게 -p옵션을 주고 pid를 건네면 이새끼가 열어놓은 것(“파일”)들을 확인할 수 있다

## 표준 스트림

- 뭐 별거 없다
- 키보드로부터 입력받는 소통창구를 **표준입력(stdin)**라고 부르고
- 화면으로 출력하는 소통창구를 **표준출력(stdout)**이라 부른다
- 그리고 에러가 났을 경우 에러 핸들러와 소통하는 창구를 **표준에러(stderror)** 라고 부른다
- 프로세스가 하나 열리면 얘는 무조건 키보드로부터 입력받거나, 화면으로 출력하거나, 에러가 날 경우를 대비해야 하기 때문에 이 세 소통창구를 무조건 열어두게 된다. 근데 이 소통창구들도 결국에는 “파일”이기 때문에 얘네들한테도 파일번호(file descriptor)가 붙게되는데 유닉스 시스템에서는 얘네들의 번호를 고정시켜놓았다
    - stdin = 0번, stdout = 1번, stderror = 2번
- 따라서 니가 어떤 프로세스를 열고 얘가 열어놓은 파일들이 뭐가 있나 lsof를 때려보면 0, 1, 2는 무조건 나오게 된다. 그리고 만약 이 프로세스가 추가적으로 “파일”을 열면 여기에는 3번부터 번호가 매겨지게 되는 것 이다

## Pipe(|), Redirection(<, >)

- 얘네들은 표준 입출력을 키보드나 화면이 아닌 다른 파일이나 프로세스로 바꿔주는 쉘 명령어이다

### Pipe

./process1_ | ./process2_

- 난 저게 첨에는 or연산인줄 알았지뭐야
- process1_에서 화면에 출력할꺼를 임시 저장소에 저장해놨다가 process2_에서 키보드로부터 입력받을 거를 저걸로 바꿔치기하는 방식으로 진행된다고 생각하면 된다

### Redirection

./process1_ > text_.txt

./process2_ < text_.txt

- 프로세스 > 문서 일케 해주면 화면에 출력할거를 저 문서에 저장
- 프로세스 < 문서 일케 해주면 키보드로 입력받을거를 저 문서의 내용으로 대체
- 프로세스를 먼저 적어야 된다! - (문서 > 프로세스)이렇게는 안되더라

## FIFO

- 얘도 동일하게 입출력 소스를 바꿔주는 역할인데 pipe나 redirection과는 다음과 같은 차이점이 있다
    1. Named PIPE이다. 즉, 그냥 pipe는 중간 임시저장 파일을 남기지 않는데 비해 얘는 redirection을 두번 쓴거마냥 중간파일을 남긴다(pipe는 시스템 내부의 임시 공간을 사용하고 fifo는 파일 하나를 커널 버퍼로 지정해서 사용하게 된다)
    2. 그리고 pipe는 단방향 통신인데 비해 얘는 양방향 통신이 가능하다
    3. 얘는 쉘 명령어라 아니라 코드로 실행이 가능하다
- **mkfifo**함수로 fifo를 만들어 줄 수 있는데 사용하고싶으면 구글링이나 하셈