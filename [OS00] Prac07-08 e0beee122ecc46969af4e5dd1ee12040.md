# [OS00] Prac07-08

1. 작동원리
    1. Server.c 함수 설명(main함수 제외)
- mkmem() : mmap()함수를 이용해 공유 메모리를 생성한다. 생성하는 과정은 open()함수를 이용해 먼저 파일을 연 후 ftruncate()함수를 이용해 이 파일의 사이즈를 조정해준다(파일의 사이즈가 0이면 메모리 매핑을 사용할 수 없기 때문이다.) 그리고 mmap()함수를 이용해 이 파일을 메모리랑 연동시켜주고 주소를 전역변수에 저장한 후 파일을 닫는다. 이제 이 메모리 공간에 값을 넣으면 자동으로 파일이랑 연동되어 파일에 저장된 값도 변경되는 구조이다. 서버에서 클라이언트로 값을 보내는 용도로 사용할 mem_s2c와 클라이언트에서 서버로 값을 보낼 용도로 사용할 mem_c2s 총 두개를 생성해준다.
- mksem() : 이름을 가지는 세마포어를 생성한다. 서버에서는 총 세개의 세마포어를 생성하는데, sem_s2c는 서버에서 클라이언트로 보내는 용도로의 메모리에 접근하는 것을 통제하기 위함이며, sem_c2s는 클라이언트에서 서버로 보내는 용도로의 메모리에 접근하는 것을 통제하기 위함이다. 이 두 세마포어는 초깃값으로 0을 가지게 되는데, 이것은 서버나 클라이언트가 공유메모리에 값을 입력해 상대방에게 수신해야 할 메세지가 있다는 것을 알려주기 위한 용도로 사용한다. 또한 sem_ready는 서버 하나와 클라이언트 둘 총 세 프로세스의 접근만을 허락하기 위한 용도이다. 세마포어 초깃값을 지정해 줬음에도 초깃값과 다른 값을 가지는 세마포어가 생성되는 경우가 있어 for문을 이용해 원하는 값을 가지도록 설정해주었다.
- send() : 서버에서 클라이언트로 값을 보내는 용도로의 메모리인 mem_s2c에 접근해 값을 저장하는 용도만 하는 함수이다.
- recv() : 클라이언트에서 서버로 값을 받는 용도로의 메모리인 mem_c2s에 접근해 값을 가져오는 용도만 하는 함수이다.
- print_msg() : pid, 입력숫자, 스트라이크, 볼을 정해진 형식에 따라 화면에 출력하는 함수이다.
- controller() : 매개변수로 클라이언트로부터 보내온 값을 입력 받으면 먼저 이 값을 pid와 입력숫자로 분리한다. 그후 입력숫자를 생성한 랜덤숫자와 비교해 스트라이크와 볼을 계산하고 이것들을 이용해 print_msg함수를 호출하여 화면에 출력한다. 이제 pid, 입력숫자, 스트라이크, 볼의 값을 “pid=입력숫자:스트라이크&볼”의 형식을 가지는 문자열로 바꿔 클라이언트한테 보낼 메시지를 생성한 후, 스트라이크가 3인지 확인해 게임이 끝나야 되는지를 확인한다. 게임이 끝나야 한다면 w_pid에 우승자의 pid를 저장하고 게임의 상태를 나타내는 state 전역변수의 값을 1로 바꿔 게임이 끝나도록 한다.
- del_all() : 할당한 메모리 공간과 세마포어를 전부 해제하는 함수이다.
    1. Client.c 함수 설명(main함수 제외)
- opmem() : 서버에서 만들어 놓은 파일을 또다른 메모리공간에 연동시켜 클라이언트에서도 이 파일을 사용할 수 있도록 해주는 함수이다. 이렇게 함으로 서버와 클라이언트는 하나의 파일을 공유하며 값을 주고받되, 이 파일의 값을 불러오고 수정하는 일은 각자의 메모리공간을 활용하게 되는 구조이다.
- opsem() : 서버에서 만들어 놓은 세마포어를 이 프로세스에서도 사용할 수 있도록 하는 함수이다. 다만 클라이언트에서는 두 클라이언트가 번갈아 실행되는 것을 지원하기 위해 sem_wclient라는 세마포어를 하나 더 추가한다.
- send() : 서버에서와 마찬가지로 mem_c2s 메모리에 값을 입력하는 것만 수행하는 함수이다.
- recv() : 마찬가지로 mem_s2c메모리에서 값을 읽어오는 것만 수행하는 함수이다.
- print_msg() : pid, 입력값, 스트라이크, 볼 값을 입력 받아 화면에 정해진 형식대로 출력하는 함수이다.
- send_controller() : 서버로 보낼 값을 생성하는 함수이다. 사용자로부터 세자리 숫자를 입력받고, 이것을 “pid=입력값”의 양식을 따르는 문자열로 변환해 반환하게 된다.
- recv_controller() : 서버에서 받은 값을 처리하는 함수이다. 받은 값은 “pid=입력값:스트라이크&볼”의 형식을 갖추고 있으므로 ‘=’와 ‘:’, ‘&’를 기준으로 값을 분리해 pid, 입력값, 스트라이크, 볼의 값을 얻어낸다. 이 값을 print_msg()함수에 넣어 화면에 출력하고, 스트라이크 값이 3일 때 게임을 종료하되 pid의 값이 자신과 같으면 전역변수 end_state의 값을 1로 바꿔 자신이 이긴 것으로 처리하고, pid값이 다르면 -1로 바꿔 자신이 진 것으로 처리하게 한다.
- dsel_all() : 할당받은 메모리와 세마포어를 전부 해제하는 함수이다.
    1. Server와 Client의 main함수 작동 과정
- 일단 먼저 server의 main함수가 작동을 하면 난수값을 생성해 화면에 출력하고 전역변수인 r_num에 저장한다. 그리고 sem_ready의 값을 하나 낮춘 후 이 값이 0이 될 때까지 sem_getvalue()함수와 while반복문을 이용해 기다리게 된다. 이제 클라이언트를 실행시키면 sem_ready를 감소시키고 여기서도 이 값이 0이 될 때까지 기다린다. 클라이언트가 둘 다 들어오면 sem_ready의 값이 0이되어 서버와 두 클라이언트 모드 게임이 시작되게 된다.
- 게임이 시작되면 서버에는 시작문구를, 클라이언트에는 시작문구와 해당 프로세스의 pid를 화면에 출력한다. 그리고 서버의 경우에는 게임의 진행/종료상태를 나타내는 전역변수인 state의 값이 0인동안, 즉, 게임이 종료되지 않은 상태인 동안 while문이 돌아가며 클라이언트의 입력을 처리하게 된다
- 서버가 클라이언트의 입력을 처리하는 과정은 다음과 같다 : 먼저 sem_c2s에 wait를 걸어 클라이언트가 값을 mem_c2s에 넣어주기를 기다린다.(클라이언트는 mem_c2s에 값을 저장하고 sem_c2s를 post시키게 된다.) 클라이언트가 값을 넣어주면 recv함수를 통해 mem_c2s의 값을 받아오고 이것을 strcpy를 통해 지역변수 inbuf로 가져오게 된다. 그후 이 값을 controller함수로 보내 송신할 메시지를 생성해 지역변수인 outbuf에 넣어주고, send()함수를 통해 mem_s2c에 넣어준다. 그리고 sem_s2c의 값을 두 번 post해 두 클라이언트가 받을 수 있도록 한다.
- 클라이언트가 사용자로부터 값을 입력 받아 서버로 넘겨주는 과정은 다음과 같다 : 일단 sem_trywait(sem_wclient)을 통해 클라이언트의 우선권을 정한다. 여기서 sem_wait이 아닌 sem_trywait을 쓰는 이유는 sem_wait의 경우 세마포어의 값이 0일 경우 대기를 하는 반면 sem_trywait의 경우에는 0일 경우 기다리지 않고 -1을 반환하기 때문에 세마포어를 잠그는데 실패한 경우에의 동작을 지정해 중 수 있기 때문이다. 우선권이 있는 프로세스, 즉, sem_wclient를 먼저 잠근 프로세스는 바로 사용자로부터 값을 입력 받는 단계로 가게 되고, 우선권이 없는 프로세스, 즉, 한발 늦어 sem_wclient를 잠그지 못한 프로세스는 우선권이 있는 프로세스가 먼저 서버로 데이터를 보내 서버에서 처리한 후 보내주는 값을 수신할 수 있도록 준비한다. 이것은 sem_s2c의 값에 wait를 걸어 서버가 값을 입력할 때까지 기다렸다가 값을 입력하면 바로 recv()함수와 recv_controll()함수를 통해 수신하는 것으로 수행된다. 수신 이후에는 자신이 우선권을 가져오기 위해 sem_wclient에 wait을 걸어 우선권을 가져올 때까지 기다리게 된다.
- 우선권을 먼저 가져온 프로세스는 바로 send_controll()함수를 통해 사용자로부터 값을 입력 받고 그것을 send()를 통해 서버로 보내게 된다. 보낸 이후에는 sem_c2s를 post해 서버가 수신할 메시지가 있다는 것을 알리고, sem_s2c를 wait해 서버가 전해주는 메시지를 기다리게 된다. 그리고 메시지가 오면 이것을 recv()함수, recv_controll()함수를 이용해 처리한 후 우선권을 넘겨주기 위해 sem_wclient를 post하게 된다. 그리고 우선권이 넘어간 후 자신이 우선권을 넘겨받기 위해 wait를 걸게 되는데 post한 이후 바로 걸어버리면 자신이 우선권을 또 가지게 될 수도 있으므로 sem_getvalue()함수와 do-while문을 통해 우선권이 다른 클라이언트로 넘어갈 때까지 기다린다. 넘어간 이후에는 마찬가지로 다른 클라이언트의 입력값을 처리한 서버의 메시지를 받기 위해 sem_s2c를 wait하고 메시지가 들어오면 recv()와 recv_controll()을 통해 메시지를 처리한다. 그리고 그 다음 우선권을 받기 위해 sem_wclient에 wait를 걸어 우선권이 넘어올 때까지 기다린다.
- 우선권을 늦게 가져온 프로세스도 이후에는 동일하게 작동한다. 우선권을 가져오고 난 뒤에는 사용자로부터 입력을 받고, 그것을 서버로 보낸 후 결과값을 받고 우선권을 넘겨주며 다시 우선권을 받을 때까지 기다리면서 상대 프로세스의 입력값이 처리될 때까지 기다린다.
1. 실행결과

![Untitled](%5BOS00%5D%20Prac07-08%20e0beee122ecc46969af4e5dd1ee12040/Untitled.png)